# https://github.com/ibarbylev/091224-ptm/blob/master/Python_08_M__math_module/classwork_08.txt
# 01. Для заданного целого числа N подсчитать количество положительных чётных чисел,
# меньше или равных N (не включая 0).
from itertools import accumulate

print(10)


# 02. Вычислите n-е число ряда Фибоначчи с помощью цикла while.
# Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 34


def fibonacci(n):
    a = 0
    b = 1
    idx = 2
    while idx < n:
        idx += 1
        a, b = b, a + b
    return b


print(fibonacci(5))


# 03. По данному натуральному числу N найдите наибольшую целую степень двойки,
# не превосходящую N.
# Выведите показатель степени и саму степень.

def power(n):
    if n < 1:
        return "Number is not natural"
    p = 0
    while True:
        if 2 ** (p + 1) > n:
            break
        p += 1
    return p, 2 ** p


print(power(8))


# 04. Дано целое число, не меньшее 2.
#  Выведите его наименьший натуральный делитель, отличный от 1.

def min_div(n):
    i = 2
    while i <= n:
        if n % i == 0:
            return i
        i += 1


print(min_div(7))

# 05. Определите сумму всех элементов последовательности, завершающейся числом 0.
# Числа, следующие за первым нулём, учитывать не нужно.
# Числа считываем с клавиатуры с помощью input()
# (Проверку, является ли введённое значение числом, делать необязательно.)

res = 0
while True:
    n = int(input())
    if n:
        res += n
    else:
        break
print(res)

# 06. Усложняем предыдущую задачу.
# Определите среднее значение всех элементов последовательности, завершающейся числом 0.
# Среднее значение - сумма всех элементов, поделенная на их количество.

res = 0
counter = 0
while True:
    counter += 1
    n = int(input())
    if n:
        res = (res + n) / counter
    else:
        break
print(round(res, 2))

# 07. Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите значение наибольшего элемента последовательности.

last = 0
while True:
    n = int(input())
    if n:
        last = n
    else:
        print(last)
        break

# 08. Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите индекс наибольшего элемента последовательности.
# Нумерация элементов начинается с нуля.

idx = -1
while True:
    n = int(input())
    if n:
        idx += 1
    else:
        print(idx)
        break

# 09. Дан объём шара X куб. ед. Найдите радиус фигуры.
#  V = 4 / 3 * pi * r ^ 3
#
#  r ^ 3 = 3 * V / 4 * pi
#
#  r = (3 * V / 4 * pi) ** 1/3

from math import pi

v = float(input())
print(round((3 * v / 4 * pi) ** 1 / 3, 2))

# 10. Пользователь вводит вещественное число и число знаков после запятой,
# до которого нам нужно его округлить это вещественное.
# Введённые значения и полученный результат вывести через пробел в одной строчке.
# Воспользуемся функцией round — встроенная функция Python.
# Ее задача — округлять число с плавающей точкой до той цифры, которую задаёт пользователь.
# Функция round помогает «улучшать» числа с плавающей точкой.
#
#  Пример:
#  3.1415926 3 -> 3.1415926 3 3.1455

n = float(input())
char_quantity = int(input())
print(n, char_quantity, round(n, char_quantity))


# 11. Так как в Python операции с вещественными числами могут давать неожиданные результаты (
# в частности, 0.1 + 0.2 не будет в точности равняться 0.3), стоит задача с этим как-то справляться.
# Требуется написать функция eqv(a, b, c), которая принимает 3 числа. Числа a и b складываются.
# Затем эта сумма сравнивается с числом “с” с определенной степенью точности.
# Точность равняется 0.01 % от большего из чисел a и b.
# Функция вернет True, если выполняется равенство, иначе False.

def eqv(a, b, c):
    if a > b:
        accuracy = a * 0.01 / 100
    if b > a:
        accuracy = b * 0.01 / 100
    return abs(c - (a + b)) <= accuracy


print(eqv(0.1, 0.2, 0.3))
